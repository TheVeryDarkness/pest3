#[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    r#Regular,
    r#Atomic,
    r#NonAtomic,
    r#ExactString,
    r#CharRange,
    r#Any,
    r#Seq,
    r#Choice,
    r#Rep,
    r#RepAtLeastOnce,
    r#Opt,
    r#RepExact,
    r#RepLeft,
    r#RepRight,
    r#RepLeftRight,
    r#Pos,
    r#Neg,
    r#Push,
    r#Pop,
    r#PopAll,
    r#Peek,
    r#PeekLeft,
    r#PeekRight,
    r#PeekLeftRight,
    r#Drop,
    r#PeekAll,
}
impl ::pest::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
    type Trivia<'i> = ::pest::typed::template::NONE;
}
mod wrapper {
    #[doc = "A wrapper for `\"+\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = "+";
    }
    #[doc = "A wrapper for `\"(\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W1;
    impl ::pest::typed::wrapper::String for W1 {
        const CONTENT: &'static ::core::primitive::str = "(";
    }
    #[doc = "A wrapper for `\")\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W2;
    impl ::pest::typed::wrapper::String for W2 {
        const CONTENT: &'static ::core::primitive::str = ")";
    }
    #[doc = "A wrapper for `\"r#\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W3;
    impl ::pest::typed::wrapper::String for W3 {
        const CONTENT: &'static ::core::primitive::str = "r#";
    }
    #[doc = "A wrapper for `\"1\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W4;
    impl ::pest::typed::wrapper::String for W4 {
        const CONTENT: &'static ::core::primitive::str = "1";
    }
    #[doc = "A wrapper for `\".\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W5;
    impl ::pest::typed::wrapper::String for W5 {
        const CONTENT: &'static ::core::primitive::str = ".";
    }
    #[doc = "A wrapper for `\"a\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W6;
    impl ::pest::typed::wrapper::String for W6 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W7;
    impl ::pest::typed::wrapper::String for W7 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"c\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W8;
    impl ::pest::typed::wrapper::String for W8 {
        const CONTENT: &'static ::core::primitive::str = "c";
    }
    #[doc = "A wrapper for `\"?\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W9;
    impl ::pest::typed::wrapper::String for W9 {
        const CONTENT: &'static ::core::primitive::str = "?";
    }
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Regular {
        content: super::generics::RepOnce<'i, super::generics::CharRange<'0', '9'>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Regular {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepOnce::<'i, super::generics::CharRange<'0', '9'>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Atomic {
        content: super::generics::Sequence3<super::generics::RepOnce<'i, CharRange>, false, super::generics::Str<super::wrapper::W0>, true, super::generics::RepOnce<'i, CharRange>, true>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Atomic {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Sequence3::<super::generics::RepOnce<'i, CharRange>, false, super::generics::Str<super::wrapper::W0>, true, super::generics::RepOnce<'i, CharRange>, true>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#NonAtomic {
        content: super::generics::Sequence2<super::generics::Str<super::wrapper::W1>, false, super::generics::Str<super::wrapper::W2>, true>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#NonAtomic {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Sequence2::<super::generics::Str<super::wrapper::W1>, false, super::generics::Str<super::wrapper::W2>, true>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#ExactString {
        content: super::generics::Str<super::wrapper::W3>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#ExactString {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Str::<super::wrapper::W3>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#CharRange {
        content: super::generics::CharRange<'0', '9'>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#CharRange {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::CharRange::<'0', '9'>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Any {
        content: ANY,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Any {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = ANY::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Seq {
        content: super::generics::Sequence3<super::generics::Str<super::wrapper::W4>, false, super::generics::CharRange<'2', '9'>, true, super::generics::Str<super::wrapper::W5>, true>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Seq {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Sequence3::<super::generics::Str<super::wrapper::W4>, false, super::generics::CharRange<'2', '9'>, true, super::generics::Str<super::wrapper::W5>, true>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Choice {
        content: super::generics::Choice9<super::generics::Str<super::wrapper::W6>, super::generics::Sequence2<super::generics::RepOnce<'i, super::generics::Str<super::wrapper::W7>>, false, RepAtLeastOnce, true>, super::generics::Sequence4<super::generics::Positive<super::generics::Str<super::wrapper::W8>>, false, Choice, true, Rep, true, Opt, true>, Peek, PeekLeft, PeekRight, PeekLeftRight, Drop, PeekAll>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Choice {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Choice9::<super::generics::Str<super::wrapper::W6>, super::generics::Sequence2<super::generics::RepOnce<'i, super::generics::Str<super::wrapper::W7>>, false, RepAtLeastOnce, true>, super::generics::Sequence4<super::generics::Positive<super::generics::Str<super::wrapper::W8>>, false, Choice, true, Rep, true, Opt, true>, Peek, PeekLeft, PeekRight, PeekLeftRight, Drop, PeekAll>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Rep {
        content: super::generics::Rep<'i, super::generics::Str<super::wrapper::W7>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Rep {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Rep::<'i, super::generics::Str<super::wrapper::W7>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepAtLeastOnce {
        content: super::generics::RepOnce<'i, super::generics::CharRange<'0', '9'>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepAtLeastOnce {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepOnce::<'i, super::generics::CharRange<'0', '9'>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Opt {
        content: ::core::option::Option<super::generics::Str<super::wrapper::W9>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Opt {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = ::core::option::Option::<super::generics::Str<super::wrapper::W9>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepExact {
        content: super::generics::RepRange<'i, RepAtLeastOnce, 3usize, 3usize>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepExact {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepRange::<'i, RepAtLeastOnce, 3usize, 3usize>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepLeft {
        content: super::generics::RepMin<'i, RepExact, 1usize>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepLeft {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepMin::<'i, RepExact, 1usize>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepRight {
        content: super::generics::RepRange<'i, RepLeft, 0, 2usize>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepRight {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepRange::<'i, RepLeft, 0, 2usize>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#RepLeftRight {
        content: super::generics::RepRange<'i, RepRight, 1usize, 2usize>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#RepLeftRight {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::RepRange::<'i, RepRight, 1usize, 2usize>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Pos {
        content: super::generics::Positive<super::generics::Sequence2<SOI, false, super::generics::RepRange<'i, RepLeftRight, 2usize, 4usize>, true>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Pos {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Positive::<super::generics::Sequence2<SOI, false, super::generics::RepRange<'i, RepLeftRight, 2usize, 4usize>, true>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Neg {
        content: super::generics::Negative<super::generics::Sequence2<EOI, false, Pos, true>>,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Neg {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = super::generics::Negative::<super::generics::Sequence2<EOI, false, Pos, true>>::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Push {
        content: PUSH,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Push {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PUSH::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Pop {
        content: POP,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Pop {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = POP::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PopAll {
        content: POP_ALL,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PopAll {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = POP_ALL::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Peek {
        content: PEEK,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Peek {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PEEK::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekLeft {
        content: PEEK,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekLeft {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PEEK::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekRight {
        content: PEEK,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekRight {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PEEK::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekLeftRight {
        content: PEEK,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekLeftRight {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PEEK::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#Drop {
        content: DROP,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#Drop {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = DROP::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub struct r#PeekAll {
        content: PEEK_ALL,
    }
    impl<'i> ::pest::typed::TypedNode<'i, super::Rule> for r#PeekAll {
        fn try_parse_with_partial(input: ::pest::Position<'i>, stack: &mut ::pest::Stack<::pest::Span<'i>>, tracker: &mut ::pest::typed::Tracker<'i, super::Rule>) -> ::core::option::Option<(::pest::Position<'i>, Self)> {
            let (pos, content) = PEEK_ALL::try_parse_with_partial(input, stack, tracker)?;
            let res = Self { content };
            ::core::option::Option::Some((pos, res))
        }
    }
}
#[doc = "Used generics."]
pub mod generics {
    pub use pest::choice::Choice9;
    pub use pest::sequence::Sequence2;
    pub use pest::sequence::Sequence3;
    pub use pest::sequence::Sequence4;
    use pest::typed::{template, TypedNode};
    pub use template::{CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Push, Rep, RepOnce, Str};
}
