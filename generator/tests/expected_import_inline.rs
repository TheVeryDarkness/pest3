#[allow(
    dead_code,
    missing_docs,
    non_camel_case_types,
    clippy::upper_case_acronyms
)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    r#x,
    r#xx,
}
impl ::pest3::typed::RuleType for Rule {
    const EOI: Self = Rule::EOI;
    type OptionalTrivia<'i> = rules::__OptionalTrivia<'i>;
    type MandatoryTrivia<'i> = rules::__MandatoryTrivia<'i>;
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    pub type __OptionalTrivia<'i> = ::pest3::typed::template::Empty;
    pub type __MandatoryTrivia<'i> = ::pest3::typed::template::Empty;
    pub mod minimal {
        #[doc = "A minimal grammar file."]
        #[allow(
            dead_code,
            missing_docs,
            non_camel_case_types,
            clippy::upper_case_acronyms
        )]
        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
        pub enum Rule {
            EOI,
            #[doc = "A rule that matches a string \"x\"."]
            r#x,
        }
        impl ::pest3::typed::RuleType for Rule {
            const EOI: Self = Rule::EOI;
            type OptionalTrivia<'i> = rules::__OptionalTrivia<'i>;
            type MandatoryTrivia<'i> = rules::__MandatoryTrivia<'i>;
        }
        #[doc = "Definitions of statically typed nodes generated by pest-generator."]
        pub mod rules {
            pub type __OptionalTrivia<'i> = ::pest3::typed::template::Empty;
            pub type __MandatoryTrivia<'i> = ::pest3::typed::template::Empty;
            #[doc = "Generated for rule `x`. Grammar: `\"x\"`."]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #[allow(non_camel_case_types)]
            pub struct r#x<'i> {
                #[doc = r" Matched structure."]
                pub content: super::super::super::generics::Str<super::super::super::wrapper::W0>,
                #[doc = r" Matched span."]
                pub span: ::pest3::Span<'i>,
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3::typed::wrapper::Rule for r#x<'i> {
                type Rule = super::Rule;
                const RULE: super::Rule = super::Rule::r#x;
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3::typed::FullRuleStruct<'i> for r#x<'i> {
                type Inner = super::super::super::generics::Str<super::super::super::wrapper::W0>;
                type Content = super::super::super::generics::Str<super::super::super::wrapper::W0>;
                #[inline]
                fn new(
                    content: <Self as ::pest3::typed::FullRuleStruct<'i>>::Content,
                    span: ::pest3::Span<'i>,
                ) -> Self {
                    Self { content, span }
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3::typed::PairContainer<super::Rule> for r#x<'i> {
                fn for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
                ) {
                    self.content.for_self_or_for_each_child_pair(f)
                }
                fn for_self_or_for_each_child_pair(
                    &self,
                    f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
                ) {
                    use pest3::typed::PairTree;
                    f(self.as_pair_tree())
                }
            }
            #[allow(non_camel_case_types)]
            impl<'i> ::pest3::typed::PairTree<super::Rule> for r#x<'i> {
                fn get_span(&self) -> (::pest3::std::usize, ::pest3::std::usize) {
                    (self.span.start(), self.span.end())
                }
            }
        }
    }
    #[doc = "Generated for rule `x`. Grammar: `minimal::x`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#x<'i> {
        #[doc = r" Matched structure."]
        pub content: minimal::rules::r#x<'i>,
        #[doc = r" Matched span."]
        pub span: ::pest3::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::wrapper::Rule for r#x<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#x;
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::FullRuleStruct<'i> for r#x<'i> {
        type Inner = minimal::rules::r#x<'i>;
        type Content = minimal::rules::r#x<'i>;
        #[inline]
        fn new(
            content: <Self as ::pest3::typed::FullRuleStruct<'i>>::Content,
            span: ::pest3::Span<'i>,
        ) -> Self {
            Self { content, span }
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::PairContainer<super::Rule> for r#x<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
        ) {
            use pest3::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::PairTree<super::Rule> for r#x<'i> {
        fn get_span(&self) -> (::pest3::std::usize, ::pest3::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
    #[doc = "Generated for rule `xx`. Grammar: `(x - x)`."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    #[allow(non_camel_case_types)]
    pub struct r#xx<'i> {
        #[doc = r" Matched structure."]
        pub content: super::generics::Sequence2<r#x<'i>, 0u8, r#x<'i>, 0u8>,
        #[doc = r" Matched span."]
        pub span: ::pest3::Span<'i>,
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::wrapper::Rule for r#xx<'i> {
        type Rule = super::Rule;
        const RULE: super::Rule = super::Rule::r#xx;
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::FullRuleStruct<'i> for r#xx<'i> {
        type Inner = super::generics::Sequence2<r#x<'i>, 0u8, r#x<'i>, 0u8>;
        type Content = super::generics::Sequence2<r#x<'i>, 0u8, r#x<'i>, 0u8>;
        #[inline]
        fn new(
            content: <Self as ::pest3::typed::FullRuleStruct<'i>>::Content,
            span: ::pest3::Span<'i>,
        ) -> Self {
            Self { content, span }
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::PairContainer<super::Rule> for r#xx<'i> {
        fn for_each_child_pair(
            &self,
            f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
        ) {
            self.content.for_self_or_for_each_child_pair(f)
        }
        fn for_self_or_for_each_child_pair(
            &self,
            f: &mut impl ::pest3::std::FnMut(::pest3::token::Pair<super::Rule>),
        ) {
            use pest3::typed::PairTree;
            f(self.as_pair_tree())
        }
    }
    #[allow(non_camel_case_types)]
    impl<'i> ::pest3::typed::PairTree<super::Rule> for r#xx<'i> {
        fn get_span(&self) -> (::pest3::std::usize, ::pest3::std::usize) {
            (self.span.start(), self.span.end())
        }
    }
}
mod wrapper {
    #[doc = "A wrapper for `\"x\"`."]
    #[derive(Clone, Debug, Hash, PartialEq, Eq)]
    pub struct W0;
    impl ::pest3::typed::wrapper::String for W0 {
        const CONTENT: &'static ::core::primitive::str = "x";
    }
}
pub use pest3::typed::unicode;
#[doc = "Used generics."]
pub mod generics {
    pub use pest3::sequence::Sequence2;
    pub use pest3::typed::template::{
        CharRange, Insens, Negative, PeekSlice1, PeekSlice2, Positive, Rep, RepMax, RepMin,
        RepMinMax, RepOnce, Str, ANY as any, ASCII as ascii, ASCII_ALPHA as ascii_alpha,
        ASCII_ALPHANUMERIC as ascii_alphanumeric, ASCII_ALPHA_LOWER as ascii_alpha_lower,
        ASCII_ALPHA_UPPER as ascii_alpha_upper, ASCII_BIN_DIGIT as ascii_bin_digit,
        ASCII_DIGIT as ascii_digit, ASCII_HEX_DIGIT as ascii_hex_digit,
        ASCII_NONZERO_DIGIT as ascii_nonzero_digit, ASCII_OCT_DIGIT as ascii_oct_digit,
        DROP as drop, EOI, EOI as eoi, NEWLINE as newline, PEEK as peek, PEEK_ALL as peek_all,
        POP as pop, POP_ALL as pop_all, PUSH as push, SOI, SOI as soi,
    };
}
